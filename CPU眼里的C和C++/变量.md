# 普通变量
1. 变量是内存地址的别名,本质等同于变量地址的指针*操作； int a = 10;定义个变量a,a变量所在地址里写入10；等价于 *(&a) = 10;

# 指针变量
1. 指针变量和普通变量没有区别，也是内存地址的别名，指针变量地址里存储的是所指变量的地址； int *p = &a;p的变量里存放的是a变量的地址；
2. 指针*操作：对所指变量内存进行读、写操作；
3. 指针占字节长度：不同类型的指针变量，所占字节数是相同的，以32位处理器为例，指针占4字节；
4. 指针+运算：
```c
    char  *p;     p+1 = value(p) + sizeof(char)
    short *p;     p+1 = value(p) + sizeof(short)
    int   *p;     P+1 = value(p) + sizeof(int)
    long  *p;     p+1 = value(p) + sizeof(long)
    int  *p[10];  p+1 = value(p) + sizeof(int *)
    int  **p;     p+1 = value(p) + sizeof(int *)
    int (*p)[10]; p+1 = value(p) + sizeof(int[10])
```
5. 野指针：没有赋"合法"值的指针，访问时，会段错误。

```c
    typedef struct {
        int a;
        int b;
    } my_struct;

    int main()
    {
        int a = 10;  // 普通赋值，本质也是给变量a所在的内存地址赋值，对应汇编指令：mov    DWORD PTR [rbp-0x4],0x1
        *(&a) = 20;  // 指针操作：&拿到a的地址，"*"对a的内存地址赋值，对应汇编指令：mov   DWORD PTR [rbp-0x4],0x14
        my_struct test = {1, 2};

        test.a = 3;                    // "." 结构体成员赋值，本质也是通过内存地址进行赋值，对应汇编指令：mov    DWORD PTR [rbp-0x4],0x3
        test.b = 4;                    // "." 结构体成员赋值，本质也是通过内存地址进行赋值，对应汇编指令：mov    DWORD PTR [rbp-0x8],0x4
        ((my_struct *)(&test))->a = 5; // 指针操作：(my_struct *)(&test)拿到成员地址，再使用 "->a"本质也是对a的内存地址赋值，对应汇编指令：mov    DWORD PTR [rbp-0x8],0x5
    }
    // 变量读、写，其本质还是等同于对变量地址的指针*操作。正如变量的定义所言，变量不过是内存地址空间的别名，但这里的变量不包括函数参数。

    // 关键点：别名的理解
    // 变量名 a 是内存地址的别名，但它并不等同于内存地址本身。
    // 通过变量名 a，你可以访问内存中的数据，但 a 本身只是一个符号，而不是内存地址。

    // 在C语言中，变量名是内存地址空间的别名，具体来说：
    // 当你声明一个变量时，例如 int a = 10，编译器会为变量 a 分配一块内存空间（例如4个字节）。
    // 这块内存空间的起始地址就是 a 的地址，可以通过 &a 获取。
    // 变量名 a 是程序员用来访问这块内存的标识符，它间接引用了这块内存地址。

    // 别名的核心特点
    // 间接性：别名是对原始对象的间接引用，而不是直接操作原始对象。
    // 方便性：别名可以简化代码或命令，使其更易读和使用。
    // 非等同性：别名并不等同于原始对象，它只是原始对象的一个替代名称。

    // 类比理解
    // 为了更好地理解“别名”的概念，可以用以下类比：
    // 变量名 a：就像是你家的门牌号“幸福路123号”。
    // 内存地址 0x7ffee4b7c9fc：就像是你家的实际地理位置（经纬度）。
    // 别名关系：门牌号“幸福路123号”是你家地理位置的别名，但它并不等同于经纬度本身。通过门牌号，你可以找到你家，但门牌号本身并不是地理位置。

    // 为什么需要别名？
    // 方便性：直接操作内存地址（如 0x7ffee4b7c9fc）非常繁琐且容易出错。通过变量名（如 a），程序员可以更方便地访问内存中的数据。
    // 可读性：变量名可以赋予语义，例如 int age = 25;，这样代码更易读和理解。
    // 抽象性：变量名隐藏了底层的内存地址细节，使程序员可以专注于逻辑实现。


    // 普通别名 VS 间接别名 VS 地址
    // 普通别名：
    // 直接引用内存中的数据，例如 a 或 pt1.x。
    // 通过变量名直接访问数据。

    // 间接别名：
    // 通过指针间接引用内存中的数据，例如 *p 或 (*p).x或者p->x，"->是语法糖"
    // 通过指针间接访问数据。
    // 指针：一张地图，上面标注了你家的位置（地址）。

    #include <stdio.h>

    int main() {
        int a = 10;      // 普通别名
        int *p = &a;     // 指针

        a = 20;          // 普通别名写数据
        *p = 30;         // 间接别名写数据

        printf("a 的值: %d\n", a);
        return 0;
    }

    main:
        ; int a = 10;
        mov dword ptr [a], 10

        ; int *p = &a;
        lea eax, dword ptr [a]  ; 将 a 的地址加载到 eax
        mov dword ptr [p], eax  ; 将 eax 的值（a 的地址）存储到 p

        ; a = 20;
        mov dword ptr [a], 20

        ; *p = 30;
        mov eax, dword ptr [p]  ; 将 p 的值（a 的地址）加载到 eax
        mov dword ptr [eax], 30 ; 将 30 写入 eax 指向的内存地址

        ; printf("a 的值: %d\n", a);
        mov eax, dword ptr [a]  ; 将 a 的值加载到 eax
        push eax                ; 将 eax 的值（a 的值）压栈
        call printf             ; 调用 printf 函数

        ; return 0;
        xor eax, eax            ; 将 eax 清零
        ret

    // 普通别名写数据：对应的汇编指令是 mov dword ptr [a], value，直接操作内存地址。
    // 间接别名写数据：对应的汇编指令是 mov eax, dword ptr [p] 和 mov dword ptr [eax], value，需要通过指针访问内存。
```

