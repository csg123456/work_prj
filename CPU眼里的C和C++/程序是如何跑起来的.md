1. 预处理（Preprocessing）
作用：处理源代码中的预处理指令，如宏定义、条件编译、文件包含等。
工具：通常由预处理器（如 cpp）完成。
输出：生成一个经过预处理的源代码文件（通常以 .i 或 .ii 为扩展名）。gcc -E hello.c -o hello.i

2. 编译（Compilation）
作用：将预处理后的源代码转换为汇编代码。
工具：由编译器（如 gcc、clang）完成。
输出：生成汇编代码文件（通常以 .s 为扩展名）。gcc -S hello.i -o hello.s

3. 汇编（Assembly）
作用：将汇编代码转换为机器代码（目标文件）,并为代码和数据生成相对地址。
工具：由汇编器（如 as）完成。
输出：生成目标文件（通常以 .o 或 .obj 为扩展名）。gcc -c hello.s -o hello.o

目标文件通常包含以下部分：

文件头：描述文件的基本信息，例如文件类型、目标架构、段表位置等。
段（Sections）：存储代码、数据、符号表等信息。
符号表（Symbol Table）：记录符号的定义和引用。
重定位表（Relocation Table）：记录需要链接器处理的地址引用。
调试信息（可选）：存储调试所需的额外信息。

4. 链接（Linking）
作用：将多个目标文件以及库文件合并，生成最终的可执行文件,并基于链接脚本或默认的内存布局模型，为代码段、数据段等分配虚拟地址。
工具：由链接器（如 ld）完成。
输出：生成可执行文件（如 a.out 或 .exe）。gcc hello.o -o hello

可执行文件（如 ELF、PE 格式）通常包含以下部分：
头部信息：描述文件类型、入口地址、段表等信息。
代码段（.text）：存储程序的机器指令。
数据段（.data）：存储已初始化的全局变量和静态变量。
BSS 段（.bss）：存储未初始化的全局变量和静态变量。
符号表：存储函数和变量的符号信息（调试或链接时使用）。
重定位表：存储需要重定位的地址信息。
动态链接信息：存储动态链接库的相关信息。

5. 加载（Loading）
作用：将可执行文件加载到内存中，准备执行。将可执行文件里包含的虚拟地址通过操作系统MMU(内存管理单元)映射到真实的物理地址中；
工具：由操作系统完成。
过程：操作系统为程序分配内存空间，并将可执行文件的代码和数据加载到内存中。

要点：对于单个进程而言，通过虚拟地址以为自己拥有整个内存区域，这个实际上是进程自己的错觉，真正的物理内存是通过MMU里的页表来分配管理的；

6. 执行（Execution）
作用：CPU 从内存中读取指令并执行。
过程：CPU 从程序的入口点（通常是 main 函数）开始执行指令。
程序运行时，操作系统负责管理内存、I/O 操作、进程调度等。

详细过程：

预处理：预处理器处理 #include、#define 等指令，展开宏，处理条件编译，生成一个干净的源代码文件。

编译：编译器将预处理后的源代码转换为汇编代码。编译器会进行语法分析、语义分析、优化等操作。

汇编：汇编器将汇编代码转换为机器代码，生成目标文件。目标文件包含机器指令、数据、符号表等信息。

链接：链接器将多个目标文件以及库文件合并，解析符号引用，生成最终的可执行文件。链接器会处理静态库和动态库的链接。

加载：操作系统将可执行文件加载到内存中，分配地址空间，设置堆栈，初始化程序环境。

执行：CPU 从程序的入口点开始执行指令，程序开始运行。操作系统负责管理程序的执行过程，处理系统调用、异常等。