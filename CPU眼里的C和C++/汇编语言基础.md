# 1、CPU里的寄存器

## 1、寄存器rax:
### 全称：Register A Extended（A 寄存器的扩展）。

### 用途：
1. 通用寄存器：RAX 是一个通用寄存器，通常用于存储函数的返回值或临时数据。
2. 算术运算：在算术和逻辑运算中，RAX 通常作为累加器使用。
3. 系统调用：在 Linux 系统调用中，RAX 用于存储系统调用号。

### 特性：
1. RAX 是 64 位寄存器，但它的低 32 位可以单独访问，称为 EAX。
2. EAX 的低 16 位可以单独访问，称为 AX。
3. AX 的高 8 位和低 8 位可以单独访问，分别称为 AH 和 AL。

## 2、寄存器rbp:
### 全称：Register Base Pointer（基址指针寄存器）。
### 用途：
1. 栈帧基址：RBP 通常用于指向当前函数的栈帧基址（栈帧的底部）。
2. 局部变量访问：通过 RBP 可以方便地访问函数的局部变量和参数。

### 特性：
1. 在函数调用时，RBP 通常被保存（push）到栈中，然后被更新为当前栈帧的基址。
2. 在函数返回时，RBP 会被恢复（pop）为调用者的栈帧基址。
3. RBP 的低 32 位称为 EBP。

## 3、寄存器rsp
### 全称：Register Stack Pointer（栈指针寄存器）。

### 用途：
1. 栈顶指针：RSP 始终指向当前栈的顶部。
2. 栈操作：在函数调用、返回以及局部变量分配时，RSP 会动态调整。

### 特性：
1. 当数据被压入栈时，RSP 会减小（栈向下增长）。
2. 当数据被弹出栈时，RSP 会增加。
3. RSP 的低 32 位称为 ESP。

## 4、寄存器rdi
### 全称：Register Destination（目标寄存器）。
## 全称：Register Data Input（数据输入寄存器）。
## 用途：
1. 函数参数：RDI 用于存储函数的参数。
2. 函数返回：RDI 用于存储函数的返回值。

## 6、寄存器rdx
### 全称：Register Data Extended（数据扩展寄存器）。
## 用途：
1. 函数参数：RDX 用于存储函数的参数。

## 7、寄存器rsi
### 全称：Register Source Data（数据源寄存器）。
## 用途：
1. 函数参数：RSI 用于存储函数的参数。

## 8、寄存器r8-r15
## 用途：
1. 函数参数：R8-R15 用于存储函数的参数。

## 5、寄存器rip
## 全称：Register Instruction Pointer（指令寄存器）。
## 用途：
1. 指令执行：RIP 用于存储当前指令的地址。
## 特性：
1. RIP 是一个 64 位寄存器，但它的低 32 位可以单独访问，称为 EIP。

## RAX、RBP 和 RSP 的关系
1. RAX 主要用于存储数据和函数返回值。
2. RBP 和 RSP 共同管理栈的操作：
3. RBP 指向当前栈帧的基址，用于访问局部变量和参数。
4. RSP 指向当前栈顶，用于动态调整栈空间。
5. 在函数调用时，RBP 和 RSP 会协同工作，确保栈帧的正确创建和销毁。


# 2、栈帧（Stack Frame）
1. 每个函数调用都会在栈上创建一个栈帧，用于存储局部变量、参数和返回地址。
2. 栈帧的结构通常如下：
    +-------------------+ 高地址
    |   返回地址         |
    +-------------------+
    |   保存的 RBP       |  <-- RBP 指向这里
    +-------------------+
    |   局部变量         |
    +-------------------+
    |   临时数据         |  <-- RSP 指向这里
    +-------------------+ 低地址

## 函数调用过程
1. 假设初始时：RBP 的值是 0x0000000000000000（未初始化），RSP 的值是 0x7fffffffe000（栈顶地址），栈是空的。
    寄存器状态：
    RBP = 0x0000000000000000
    RSP = 0x7fffffffe000

    栈状态：
    +-------------------+ 高地址
    |                   |
    +-------------------+
    |                   |
    +-------------------+
    |                   |
    +-------------------+ 低地址

2. push rbp 将 RBP 的值压入栈中，同时 RSP 会减小 8 字节。(栈向下生长)
    操作如下：
    RSP = RSP - 8 = 0x7fffffffdff8
    将 RBP 的值（0x0000000000000000）存储到 RSP 指向的地址。

    寄存器状态：
    RBP = 0x0000000000000000
    RSP = 0x7fffffffdff8

    栈状态：
    +-------------------+ 高地址
    |                   |
    +-------------------+
    | 0x0000000000000000|  <-- RSP 指向这里
    +-------------------+ 低地址

3. mov rbp, rsp:将 RSP 的值赋给 RBP，此时 RBP 指向当前栈顶

    操作：
    RBP = RSP = 0x7fffffffdff8

    寄存器状态：
    RBP = 0x7fffffffdff8
    RSP = 0x7fffffffdff8

    栈状态：
    +-------------------+ 高地址
    |                   |
    +-------------------+
    | 0x0000000000000000|  <-- RBP 和 RSP 指向这里
    +-------------------+ 低地址

4. pop rbp 将栈顶的值弹出并存储到 RBP 中，同时 RSP 会增加 8 字节。
    
    操作：
    将 RSP 指向的值（0x0000000000000000）加载到 RBP。
    RSP = RSP + 8 = 0x7fffffffe000

    寄存器状态：
    RBP = 0x0000000000000000
    RSP = 0x7fffffffe000

    栈状态：
    +-------------------+ 高地址
    |                   |
    +-------------------+
    |                   |  <-- RSP 指向这里
    +-------------------+ 低地址

5. 执行完 pop rbp 后，RBP 恢复到初始值（0x0000000000000000），RSP 也恢复到初始值（0x7fffffffe000），栈恢复到空的状态。
    寄存器状态：
    RBP = 0x0000000000000000
    RSP = 0x7fffffffe000

    栈状态：
    +-------------------+ 高地址
    |                   |
    +-------------------+
    |                   |
    +-------------------+ 低地址