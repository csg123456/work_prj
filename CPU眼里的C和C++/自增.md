# i++ VS ++i
## i++
- i++ 先返回i再自增1;

## ++i
- ++i 先自增1再返回i;

## 优化

- 现代编译器（如 GCC、Clang、MSVC 等）会对代码进行优化，使得 a++ 和 ++a 生成的机器代码几乎相同
- 如果 a 是基本类型（如 int、char 等），编译器会直接将 a++ 和 ++a 优化为相同的指令。
- 即使 a 是复杂类型（如类对象），如果编译器能够确定 a++ 和 ++a 的行为相同，也会进行优化。

## 示例

```c++
//C++关于前++和后++的重载示例
#include <iostream>

class MyClass {
public:
    int value;

    MyClass(int v = 0) : value(v) {}

    // 前++重载
    MyClass& operator++() {
        ++value;
        return *this; // 返回自增后的对象（左值）
    }

    // 后++重载
    MyClass operator++(int) { // 参数int表示这是一个后++操作
        MyClass temp = *this; // 保存当前值
        ++value; // 自增
        return temp; // 返回自增前的副本（右值）
    }
};

int main() {
    MyClass obj(5);

    // 前++是左值
    ++obj = MyClass(10); // 合法，因为 ++obj 返回左值
    std::cout << obj.value << std::endl; // 输出 10

    // 后++是右值
    // obj++ = MyClass(20); // 非法，因为 obj++ 返回右值
    std::cout << obj.value << std::endl; // 输出 10

    return 0;
}
```

## 总结
| 特性 |	i++ |	++i
|:----|:----|:----|
|表达式类型|	右值（prvalue）	|左值（lvalue）、
|能否被赋值	|❌ 不能|	✅ 能
|能否取地址	|❌ 不能	|✅ 能
|能否作为赋值右操作数	|✅ 能	|✅ 能
|能否作为数组下标进行赋值	|⚠️ 有限制	|✅ 能

这个区别在底层实现上是因为：

- i++ 需要返回自增前的值，因此需要创建一个临时对象来保存原值;
- ++i 直接返回自增后的对象本身，因此可以作为左值使用;