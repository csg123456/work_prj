# 常见三种文件系统总结

## 1、FATFS：

### 裸机使用场景 
    1. 单任务/裸机：两者都可关（节省内存/开销）;

### 多任务使用场景

1. ffconf.h文件中有3个宏定义关于线程安全的，FF_FS_LOCK和FF_FS_REENTRANT FF_FS_TIMEOUT FF_USE_LFN;

#### FF_FS_REENTRANT（可重入 / 线程安全）
1. 由 FatFs 模块层面控制，同一卷（volume）上对 FatFs API 的并发调用会被序列化。
2. 需要用户提供同步原语（ff_mutex_create/delete/take/give），FatFs 在内部对文件/目录操作加3. 全局或卷级互斥，防止库内部数据结构竞争。
4. 保护的是 FatFs 实现自身（缓存、链表、共享状态等）的并发一致性，不保证跨多个 API 调用的事务原子性（比如 read->modify->write）。

### FF_FS_LOCK（文件级锁）
1. 在文件对象层面控制“谁能打开/删除/重命名某个对象”等冲突行为。
2. 防止同一文件被多个文件对象以冲突方式同时打开，或者在打开时被 unlink/rename 等操作破坏。
3. 是针对文件访问冲突的逻辑约束，不替代用户空间的更高层并发控制。

2. 多任务/RTOS实践建议：
    1. FF_FS_REENTRANT = 1 —— 使 FatFs 模块可重入（线程安全）。同时必须在移植层实现同步接口：ff_mutex_create/ff_mutex_delete/ff_mutex_take/ff_mutex_give。
    2. 配合上设置 FF_FS_TIMEOUT（超时时间，单位 OS tick），避免长时间阻塞。
    3. FF_FS_LOCK > 0 —— 启用文件级锁有两重含义：1、防止多次打开同一个文件。2、其数值决定内部锁表可记录的被锁对象个数（设置为预计同时受锁控制的对象数）。
    4. 若启用 LFN 且在多任务下使用，建议 FF_USE_LFN = 3（在堆上分配工作缓冲），并实现 ff_memalloc/ff_memfree。
    5. 当 FF_FS_READONLY = 1 时，FF_FS_LOCK 必须为 0。
    6. FF_FS_REENTRANT 保护的是 FatFs 库内部并发访问，不保证跨多次 API 调用的事务性（应用层仍需自行加锁实现原子序列，事务就是多次调用API，比如打开创建文件，然后写入、关闭文件，这个过程就是事务，但是不保证跨 API 调用事务性）。
    7. 设置合适的 FF_FS_LOCK 大小以避免锁表溢出；对关键事务在应用层再加 mutex。

3. 配置如下：
    1. FF_USE_LFN = 3
    2. FF_MAX_LFN = 255
    3. FF_FS_REENTRANT = 1（并实现 ff_mutex_create/delete/take/give）
    4. FF_FS_LOCK > 0（按并发文件数设置）——如果需要防止对象级冲突

4. 移植的时候可以自定义一个fatfs_port.h头文件，在里面定义一些用户宏，无需破坏fatfs源码，很多开源代码都这么操作;

文件系统中宏的解释如下：
```C
#ifndef FF_FS_LOCK
#define FF_FS_LOCK		1
/* The option FF_FS_LOCK switches file lock function to control duplicated file open
/  and illegal operation to open objects. This option must be 0 when FF_FS_READONLY
/  is 1.
/
/  0:  Disable file lock function. To avoid volume corruption, application program
/      should avoid illegal open, remove and rename to the open objects.
/  >0: Enable file lock function. The value defines how many files/sub-directories
/      can be opened simultaneously under file lock control. Note that the file
/      lock control is independent of re-entrancy. */
#endif

#ifndef FF_FS_REENTRANT
#define FF_FS_REENTRANT	1
#define FF_FS_TIMEOUT	1000
/* The option FF_FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs
/  module itself. Note that regardless of this option, file access to different
/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
/  and f_fdisk() function, are always not re-entrant. Only file/directory access
/  to the same volume is under control of this featuer.
/
/   0: Disable re-entrancy. FF_FS_TIMEOUT have no effect.
/   1: Enable re-entrancy. Also user provided synchronization handlers,
/      ff_mutex_create(), ff_mutex_delete(), ff_mutex_take() and ff_mutex_give()
/      function, must be added to the project. Samples are available in ffsystem.c.
/
/  The FF_FS_TIMEOUT defines timeout period in unit of O/S time tick.
*/

#define FF_USE_LFN		3
#define FF_MAX_LFN		255
/* The FF_USE_LFN switches the support for LFN (long file name).
/
/   0: Disable LFN. FF_MAX_LFN has no effect.
/   1: Enable LFN with static  working buffer on the BSS. Always NOT thread-safe. 开启会增加代码空间
/   2: Enable LFN with dynamic working buffer on the STACK. 一般使用OS设置
/   3: Enable LFN with dynamic working buffer on the HEAP.
/
/  To enable the LFN, ffunicode.c needs to be added to the project. The LFN function
/  requiers certain internal working buffer occupies (FF_MAX_LFN + 1) * 2 bytes and
/  additional (FF_MAX_LFN + 44) / 15 * 32 bytes when exFAT is enabled.
/  The FF_MAX_LFN defines size of the working buffer in UTF-16 code unit and it can
/  be in range of 12 to 255. It is recommended to be set it 255 to fully support LFN
/  specification.
/  When use stack for the working buffer, take care on stack overflow. When use heap
/  memory for the working buffer, memory management functions, ff_memalloc() and
/  ff_memfree() exemplified in ffsystem.c, need to be added to the project. */
```

```c
ffsystem.c中实现下面锁的接口:文件互斥锁

#include "FreeRTOS.h"
#include "semphr.h"

static SemaphoreHandle_t ff_mutex;

int ff_mutex_create (void)
{
    ff_mutex = xSemaphoreCreateMutex();
    return ff_mutex ? 0 : -1;
}
int ff_mutex_delete (void)
{
    vSemaphoreDelete(ff_mutex);
    return 0;
}
int ff_mutex_take (UINT timeout)   // timeout 单位：OS tick 或 ms 视实现
{
    return (xSemaphoreTake(ff_mutex, pdMS_TO_TICKS(timeout)) == pdTRUE) ? 0 : -1;
}
int ff_mutex_give (void)
{
    return (xSemaphoreGive(ff_mutex) == pdTRUE) ? 0 : -1;

}
ffsystem.c中实现下面锁的接口:内存申请
```c
/*------------------------------------------------------------------------*/
/* Allocate/Free a Memory Block                                           */
/*------------------------------------------------------------------------*/

#include <stdlib.h>		/* with POSIX API */

void* ff_memalloc (	/* Returns pointer to the allocated memory block (null if not enough core) */
	UINT msize		/* Number of bytes to allocate */
)
{
	return osal_malloc((size_t)msize);	/* Allocate a new memory block */
}


void ff_memfree (
	void* mblock	/* Pointer to the memory block to free (no effect if null) */
)
{
	osal_free(mblock);	/* Free the memory block */
}
```

## 2、linux 文件系统

### 内核层同步原语
1. 文件系统在内核内部用多种锁保护并发：spinlock、mutex、rwsem、seqlock、RCU 等。不同锁用于不同粒度的数据结构（页缓存、inode、dentry、superblock、journal 等）。
2. lockdep/lockstat 用于调试死锁/锁顺序问题。

### VFS 与常用锁
1. inode/dentry/superblock 级别的锁（现代内核用 inode_lock、dentry lock、sb->s_lock/rwsem 等）保护元数据（创建/删除/重命名/权限修改等）。
2. page cache（页缓存）用 page 或 radix-tree 层面的锁与页标志保证并发读写一致性。
3. journaling（如 ext4）保证元数据一致性（崩溃恢复），但不替代并发访问控制。

### 文件描述符与偏移量
1. 每个文件描述符有独立的 file->f_pos；同一进程/线程共享 fd 时读写会共享偏移，lseek+write 非原子。
2. pwrite/pread 能在内核层使用用户提供的偏移实现原子写/读（不修改 file->f_pos）。
3. 打开文件时使用 O_APPEND 内核会保证“逐次追加”的原子性（内核在写入前取得并更新偏移）。

### 对用户可见的并发控制
1. POSIX 文件锁（fcntl F_SETLK/F_SETLKW）和 flock（advisory）供用户空间并发控制；默认是 advisory（需要应用配合）。也可通过挂载选项启用强制（mandatory）锁，但少用且有风险。
2. 应用层仍需在需要事务性或跨多次 syscall 的原子性时自己加锁（mutex/进程间锁/数据库事务等）。

### 文件锁 fcntl/flock


### 并发安全的实践建议
1. 依赖内核和文件系统保证数据结构一致性；但对业务级并发控制（读写序列、事务）应使用 fcntl/flock 或应用层互斥。
2. 使用 pwrite/pread 或写入经 O_APPEND 的场景避免 race；对复杂操作（检查-修改-写回）在用户层加锁。
3. 在多线程/多进程环境下测试边界条件（性能、锁争用、死锁、超时）。

总结：Linux 文件系统通过内核锁与页缓存机制在内核内部保证并发访问的一致性与完整性；但用户可见的操作原子性和业务级并发控制通常需要借助 POSIX 文件锁或应用层同步来实现。

## 3、LittleFS

### 裸机使用场景

### RTOS多任务使用场景